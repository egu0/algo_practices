

> 输入一个 int 类型的值 $N$，构造一个长度为 $N$ 的数组 `arr` 并返回。
>
> 要求：对于任意的 `i<k<j`，都满足 `arr[i] + arr[j] != 2 * arr[k]`



思路：

构造一个序列 `{i, k, j}`，满足 `[i] + [j] ≠ 2 * [k]`

比如 `{2, 1, 3}`，对他进行 **“ 奇变换 ”** ，可以是 `{3, 1, 5}` 分表代表 `第 i 个奇数`

**“ 偶变换 ”** 同理为：`{2, 0, 4}`

将他们拼接到一起为 `{3, 1, 5, 2, 0, 4}` 同样满足条件

同理可以继续向上找长度为 12 的数组





<img src="images/array.assets/image-20210829175146135.png" alt="image-20210829175146135" style="zoom:80%;" />



> master 公式，计算递归方式的复杂度：
>
> **$T(N) = a * T(N/b) + O(N^d)$**

参数：

- `a` 子过程调用次数
- `b` 子过程数据规模
- `d` 其他的时间复杂度

关系：

| 关系         | T(N)复杂度      |
| ------------ | --------------- |
| $logb^a < d$ | $O(N^d)$        |
| $logb^a > d$ | $O(N^{logb^a})$ |
| $logb^a = d$ | $O(N^d * logN)$ |

 











