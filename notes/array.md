

### 构造数组

> 输入一个 int 类型的值 $N$，构造一个长度为 $N$ 的数组 `arr` 并返回。
>
> 要求：对于任意的 `i<k<j`，都满足 `arr[i] + arr[j] != 2 * arr[k]`



其中一种思路：（有很多种解法）

构造一个序列 `{i, k, j}`，满足 `[i] + [j] ≠ 2 * [k]`

比如 `{2, 1, 3}`，对他进行 **“ 奇变换 ”** ，可以是 `{3, 1, 5}` 分表代表 `第 i 个奇数`

**“ 偶变换 ”** 同理为：`{2, 0, 4}`

将他们拼接到一起为 `{3, 1, 5, 2, 0, 4}` 同样满足条件

同理可以继续向上找长度为 12 的数组



 <img src="images/array.assets/image-20210829175146135.png" alt="image-20210829175146135" style="zoom:80%;" />



> **Master 公式**，计算递归方式的复杂度：
>
> **$T(N) = a * T(N/b) + O(N^d)$**

参数：

- `a` 子过程调用次数
- `b` 子过程数据规模
- `d` 其他的时间复杂度

关系：

| 关系         | T(N)复杂度      |
| ------------ | --------------- |
| $logb^a < d$ | $O(N^d)$        |
| $logb^a > d$ | $O(N^{logb^a})$ |
| $logb^a = d$ | $O(N^d * logN)$ |

 

### bfprt算法

又称为中位数的中位数算法，线性查找数组中第 K 大（小）的数

> **BFPRT** 算法，又称为中位数的中位数算法，由5位大牛（Blum 、 Floyd 、 Pratt 、 Rivest 、 Tarjan）提出，并以他们的名字命名。参考维基上的介绍Median of medians。
> 在BFPTR算法中，仅仅是改变了快速排序Partion中的pivot值的选取，在快速排序中，我们始终选择第一个元素或者最后一个元素作为pivot，而在BFPTR算法中，每次选择五分中位数的中位数作为pivot，这样做的目的就是使得划分比较合理，从而避免了最坏情况的发生。算法步骤如下
> 1. 将 [Math Processing Error] 个元素划为 [Math Processing Error] 组，每组5个，至多只有一组由 [Math Processing Error] 个元素组成。
> 2. 寻找这 [Math Processing Error] 个组中每一个组的中位数，这个过程可以用插入排序。
> 3. 对步骤2中的 [Math Processing Error] 个中位数，重复步骤1和步骤2，递归下去，直到剩下一个数字。
> 4. 最终剩下的数字即为pivot，把大于它的数全放左边，小于等于它的数全放右边。
> 5. 判断pivot的位置与k的大小，有选择的对左边或右边递归。

链接：

- 算法原理：https://www.youtube.com/watch?v=PY7YiJQa3Lc

- 算法实现：https://zhuanlan.zhihu.com/p/31498036



### 刷题

1. **业务题**。注重分析能力，最优解就是在该题专有的业务上，找到聪明的做法。
2. **技巧题**。背后有一个数据结构、特殊算法，可以进行推广。









